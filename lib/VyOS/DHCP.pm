#!/usr/bin/perl
#
# Module: VyOS::DHCP
# Helps configure DHCPv4 and DHCPv6 interfaces.
#
# Copyright (C) 2016 VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Nick Williams <nicholas+vyos@nicholaswilliams.net>
# Date: January 2016
#
# **** End License ****
#

package VyOS::DHCP;

use strict;

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw(config_edit_interface_v4 config_edit_interface_v6
                 config_remove_interface_v4 config_remove_interface_v6
                 client_rebind_interface client_release_interface
                 client_start_if_stopped client_stop_if_running
                 client_restart client_is_running client_get_lease);

use warnings;
use lib "/opt/vyatta/share/perl5";

my $dhcp_client = '/sbin/dhcpcd';
my $dhcp_client_config = '/etc/dhcpcd.conf';
my $dhcp_client_pid = '/var/run/dhcpcd.pid';

sub _trim {
    my $str = shift;
    $str =~ s/^\s+|\s+$//g;
    return $str;
}

sub _dhcp_write_file {
    my $data = shift;

    my $date = localtime();
    my $header = "# DHCPCD configuration file\n";
    $header .= "#\n# Auto-Generated by VyOS/DHCP.pm on $date\n#\n\n";

    open(my $fh, '>', $dhcp_client_config) || die "Could not open $dhcp_client_config - $!";
    print $fh $header;
    print $fh $data;
    close $fh;
}

sub _read_config_dict {
    my %data = ('allow' => 0, 'main' => [], 'interface_names' => [], 'interfaces' => {});

    if (! -f $dhcp_client_config) {
        @{$data{'main'}} = ('nodhcp', 'nodhcp6', 'noipv4', 'noipv6', 'noipv6rs');
        return %data;
    }

    my $in_iface = 0;
    my $in_v4 = 0;
    my $in_v6 = 0;

    open(my $fh => $dhcp_client_config) || die "Could not open $dhcp_client_config - $!";
    while(my $line = <$fh>) {
        $line = _trim($line);

        next if ($line eq '');

        if (substr($line, 0, 10) eq 'interface ') {
            $in_iface = substr($line, 10);

            push @{$data{'interface_names'}}, $in_iface;
            $data{'interfaces'}{$in_iface} = ();
            $data{'interfaces'}{$in_iface}{'main'} = ();

            $in_v4 = 0;
            $in_v6 = 0;
        } elsif ($in_iface) {
            if ($line eq '# v4') {
                $data{'interfaces'}{$in_iface}{'v4'} = ();

                $in_v4 = 1;
                $in_v6 = 0;
            } elsif ($line eq '# v6') {
                $data{'interfaces'}{$in_iface}{'v6'} = ();

                $in_v4 = 0;
                $in_v6 = 1;
            } elsif ($in_v4) {
                push @{$data{'interfaces'}{$in_iface}{'v4'}}, $line;
            } elsif ($in_v6) {
                push @{$data{'interfaces'}{$in_iface}{'v6'}}, $line;
            } else {
                push @{$data{'interfaces'}{$in_iface}{'main'}}, $line;
            }
        } elsif (substr($line, 0, 1) ne '#' and substr($line, 0, 16) ne 'allowinterfaces ') {
            push @{$data{'main'}}, $line;
        }
    }

    return %data;
}

sub _write_config_to_string {
    my $params = shift;
    my %data = %$params;
    my $config = '';

    my $len = scalar @{$data{'interface_names'}};
    if ($len) {
        $config = 'allowinterfaces';
        foreach my $iface (@{$data{'interface_names'}}) {
            $config .= " $iface";
        }
    } else {
        # Add a fake placeholder interface that will not match and will exclude all interfaces
        $config = 'allowinterfaces plc0';
    }
    $config .= "\n";

    foreach my $main (@{$data{'main'}}) {
        $config .= "$main\n";
    }

    foreach my $iface (@{$data{'interface_names'}}) {
        $config .= "\ninterface $iface\n";

        foreach my $setting (@{$data{'interfaces'}{$iface}{'main'}}) {
            $config .= "$setting\n";
        }

        if (exists $data{'interfaces'}{$iface}{'v4'}) {
            $config .= "# v4\n";
            foreach my $setting (@{$data{'interfaces'}{$iface}{'v4'}}) {
                $config .= "$setting\n";
            }
        }

        if (exists $data{'interfaces'}{$iface}{'v6'}) {
            $config .= "# v6\n";
            foreach my $setting (@{$data{'interfaces'}{$iface}{'v6'}}) {
                $config .= "$setting\n";
            }
        }
    }

    return $config;
}

sub _config_edit_interface {
    my ($delineator, $interface, $common, $settings) = @_;

    my %config = _read_config_dict();

    if (!exists $config{'interfaces'}{$interface}) {
        push @{$config{'interface_names'}}, $interface;
        $config{'interfaces'}{$interface} = ();
        $config{'interfaces'}{$interface}{'main'} = ();
    }

    if (ref $common eq 'ARRAY') {
        # caller wants to replace common settings
        $config{'interfaces'}{$interface}{'main'} = [];
        foreach my $setting (@{$common}) {
            push @{$config{'interfaces'}{$interface}{'main'}}, $setting;
        }
    } elsif ($common == -1) {
        # caller wants to delete common settings
        $config{'interfaces'}{$interface}{'main'} = ();
    }

    $config{'interfaces'}{$interface}{$delineator} = [];
    foreach my $setting (@{$settings}) {
        push @{$config{'interfaces'}{$interface}{$delineator}}, $setting;
    }

    _dhcp_write_file(_write_config_to_string(\%config));
}

# Adds or replaces the provided DHCPv4 configuration for the
# specified interface in the DHCP client config file, including
# the list of allowed interfaces.
#
# $interface - The etherface name (eth0, etc.).
# $common    - 0 to leave unchanged, -1 to delete common settings,
#              an array reference (\@common) to update common settings.
# $settings  - An array reference (\@settings) to update v4 settings.
sub config_edit_interface_v4 {
    my ($interface, $common, $settings) = @_;
    _config_edit_interface('v4', $interface, $common, $settings);
}

# Adds or replaces the provided DHCPv4 configuration for the
# specified interface in the DHCP client config file, including
# the list of allowed interfaces.
#
# $interface - The etherface name (eth0, etc.).
# $common    - 0 to leave unchanged, -1 to delete common settings,
#              an array reference (\@common) to update common settings.
# $settings  - An array reference (\@settings) to update v6 settings.
sub config_edit_interface_v6 {
    my ($interface, $common, $settings) = @_;
    _config_edit_interface('v6', $interface, $common, $settings);
}

sub _config_remove_interface {
    my ($delineator, $interface) = @_;

    my %config = _read_config_dict();

    if (exists $config{'interfaces'}{$interface}) {
        if (exists $config{'interfaces'}{$interface}{$delineator}) {
            delete $config{'interfaces'}{$interface}{$delineator};
        }

        if (!exists $config{'interfaces'}{$interface}{'v4'} and
            !exists $config{'interfaces'}{$interface}{'v6'}) {
            delete $config{'interfaces'}{$interface};

            my $i = 0;
            $i++ until @{$config{'interface_names'}}[$i] eq $interface;
            if (@{$config{'interface_names'}}[$i] eq $interface) {
                splice @{$config{'interface_names'}}, $i, 1;
            }
        }
    }

    _dhcp_write_file(_write_config_to_string(\%config));
}

# Remove DHCPv4 configuration for the specified interface from
# the DHCP client config file, including the list of allowed
# interfaces if no configuration remains for the interface.
sub config_remove_interface_v4 {
    my $interface = shift;
    _config_remove_interface('v4', $interface);
}

# Remove DHCPv6 configuration for the specified interface from
# the DHCP client config file, including the list of allowed
# interfaces if no configuration remains for the interface.
sub config_remove_interface_v6 {
    my $interface = shift;
    _config_remove_interface('v6', $interface);
}

# Instruct the DHCP client to reload its configuration and
# reconfigure the specified interface. Use this after adding
# an interface to or removing an interface from the client
# configuration. Do not call this unless the client is
# running.
sub client_rebind_interface {
    my $interface = shift;

    my $cmd = "$dhcp_client --rebind $interface";
    my $ret = system($cmd);
    $ret == 0 or warn "rebind $interface with $dhcp_client failed: $?\n";
    return $ret == 0;
}

# Instructs the DHCP client to release its lease(s) for the
# specified interface and de-configure the interface. Use
# this to renew the DHCPv4 and DHCPv6 leases for an
# interface. Do not call this unless the client is running.
sub client_release_interface {
    my $interface = shift;

    my $cmd = "$dhcp_client --release $interface";
    my $ret = system($cmd);
    $ret == 0 or warn "release $interface with $dhcp_client failed: $?\n";
    return $ret == 0;
}

sub _test_pid_file_running {
    return kill 0, `cat $dhcp_client_pid`;
}

sub _remove_pid_file {
    return system("rm -f $dhcp_client_pid 2> /dev/null") == 0;
}

sub client_is_running {
    if (-f $dhcp_client_pid) {
        # The PID file exists; test it.
        if (_test_pid_file_running()) {
            # The process is running; return true.
            return 1;
        } else {
            # The process is stopped; remove the PID file.
            _remove_pid_file();
        }
    }

    # The process is not running; return false.
    return 0;
}

# Starts the DHCP client if and only if it is not running.
#
# Retuns 0 (false) if the client was already running and
# 1 (true) if it was stopped and, so, started.
sub client_start_if_stopped {
    if (client_is_running()) {
        return 0;
    }

    my $cmd = "$dhcp_client --master --background --quiet";
    system($cmd) == 0 or die "starting $dhcp_client failed: $?\n";
    return 1;
}

# Stops the DHCP client if and only if it is not running.
# Use this with caution—all DHCPv4 and DHCPv6 leases on all
# interfaces will be released.
#
# Returns 0 (false) if the client was already stopped and
# 1 (true) if it was running and, so, stopped.
sub client_stop_if_running {
    if (!client_is_running()) {
        return 0;
    }

    my $cmd = "$dhcp_client --exit 2> /dev/null";
    system($cmd) == 0 or die "stopping $dhcp_client failed: $?\n";
    return 1;
}

# Stops the DHCP client if it is running and then starts
# the DHCP client. This will release all DHCPv4 and DHCPv6
# leases on all interfaces, reload the client configuration,
# and reconfigure all DHCP interfaces.
sub client_restart {
    client_stop_if_running();
    client_start_if_stopped();
}

sub client_get_lease {
    my $interface = shift;

    my $output = `$dhcp_client --dumplease $interface`;
    my @lease = split("\n", _trim($output));
    my %lease_hash = ();

    foreach my $line (@lease) {
        my ($key, $value) = split('=', $line, 2);
        $value =~ s/'//g;
        $lease_hash{_trim($key)} = _trim($value);
    }

    return %lease_hash;
}

if (scalar @ARGV > 0 and $ARGV[0] eq 'run-tests' and substr($0, -7) eq 'DHCP.pm') {
    #####################################################
    # Unit tests for this file
    # There is no more production code below this

    sub assert_equals {
        my ($number, $expected, $actual) = @_;

        if ($expected ne $actual) {
            die "Values did not match for test #$number!\nExpected: '$expected'\nActual: '$actual'\n";
        }
        print '.';
    }

    sub file_contents {
        my $filename = shift;

        local $/ = undef;
        open FILE, $filename or die "Couldn't open file: $!";
        binmode FILE;
        my $string = <FILE>;
        close FILE;
        return $string;
    }

    print "Running tests for VyOS::DHCP!\n\n";

    my $expected = 0;
    my $date = 0;
    my @common = ();
    my @settings = ();
    my $assertions = 0;

    $dhcp_client_config = '/tmp/vyos-dhcpcd-config-unit-tests.conf';
    system("rm -f $dhcp_client_config");

    config_edit_interface_v4('eth0', 0, ['ipv4', 'dhcp']);
    $date = localtime();
    $expected = <<"EXPECTED";
# DHCPCD configuration file
#
# Auto-Generated by VyOS/DHCP.pm on $date
#

allowinterfaces eth0
nodhcp
nodhcp6
noipv4
noipv6
noipv6rs

interface eth0
# v4
ipv4
dhcp
EXPECTED
    assert_equals(++$assertions, $expected, file_contents($dhcp_client_config));

    config_remove_interface_v4('eth0');
    $date = localtime();
    $expected = <<"EXPECTED";
# DHCPCD configuration file
#
# Auto-Generated by VyOS/DHCP.pm on $date
#

allowinterfaces plc0
nodhcp
nodhcp6
noipv4
noipv6
noipv6rs
EXPECTED
    assert_equals(++$assertions, $expected, file_contents($dhcp_client_config));

    config_edit_interface_v4('eth1', ['metric 15'], ['ipv4', 'dhcp']);
    config_edit_interface_v6('eth1', 0, ['ipv6', 'dhcp6', 'ipv6rs', 'ia_na 1', 'ia_pd 2 eth2 eth3 eth4']);
    $date = localtime();
    $expected = <<"EXPECTED";
# DHCPCD configuration file
#
# Auto-Generated by VyOS/DHCP.pm on $date
#

allowinterfaces eth1
nodhcp
nodhcp6
noipv4
noipv6
noipv6rs

interface eth1
metric 15
# v4
ipv4
dhcp
# v6
ipv6
dhcp6
ipv6rs
ia_na 1
ia_pd 2 eth2 eth3 eth4
EXPECTED
    assert_equals(++$assertions, $expected, file_contents($dhcp_client_config));

    config_edit_interface_v4('eth6', 0, ['dhcp']);
    config_edit_interface_v4('eth1', -1, ['ipv4', 'dhcp', 'cool']);
    $date = localtime();
    $expected = <<"EXPECTED";
# DHCPCD configuration file
#
# Auto-Generated by VyOS/DHCP.pm on $date
#

allowinterfaces eth1 eth6
nodhcp
nodhcp6
noipv4
noipv6
noipv6rs

interface eth1
# v4
ipv4
dhcp
cool
# v6
ipv6
dhcp6
ipv6rs
ia_na 1
ia_pd 2 eth2 eth3 eth4

interface eth6
# v4
dhcp
EXPECTED
    assert_equals(++$assertions, $expected, file_contents($dhcp_client_config));

    config_edit_interface_v6('eth1', -1, ['ia_na 1', 'ia_pd 2/::/60 eth2/1/64 eth3/2/64 eth4/3/64']);
    $date = localtime();
    $expected = <<"EXPECTED";
# DHCPCD configuration file
#
# Auto-Generated by VyOS/DHCP.pm on $date
#

allowinterfaces eth1 eth6
nodhcp
nodhcp6
noipv4
noipv6
noipv6rs

interface eth1
# v4
ipv4
dhcp
cool
# v6
ia_na 1
ia_pd 2/::/60 eth2/1/64 eth3/2/64 eth4/3/64

interface eth6
# v4
dhcp
EXPECTED
    assert_equals(++$assertions, $expected, file_contents($dhcp_client_config));

    print "\n\nRan $assertions assertions OK.\n";
    system("rm -f $dhcp_client_config");

    # End unit tests
    #####################################################
}

1;
